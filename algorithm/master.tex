\documentclass{amsart}
\usepackage{tikz}

\gdef\R{\rightarrow}

\begin{document}

\null
\vskip 3cm plus 1cm
\title{Syntax tree transformation as dialgebraic fold}
\maketitle
\vskip 3cm plus 1cm

\section{Syntax tree transformations by example}

Let us see some examples of transformations between grammars.

\subsection{Concrete and abstract grammars for arithmetic expressions}

The input grammar describes the concrete syntax of arithmetic
expressions with operator precedence and parentheses.

Let $C$ be the concrete grammar.
\begin{align*}
C &\R C~+~S & (C_1) \\
C &\R S     & (C_2) \\
S &\R S~\times~F & (S_3) \\
S &\R F     & (S_4) \\
F &\R \mbox{integer} & (F_5) \\
F &\R (~C~) & (F_6)
\end{align*}

Let $A$ be the abstract grammar.
\begin{align*}
A &\R A~+~A & (A_1) \\
A &\R A~\times~A & (A_3) \\
A &\R \mbox{integer} & (A_5)
\end{align*}

Intuitively, nodes labeled $C_1,S_3,F_5$ in concrete syntax trees
gets translated respectively to nodes labeled $A_1,A_3,A_5$ in
abstract syntax trees.

This is the concrete syntax tree of the expression $3\times4+5$.
\[
\begin{tikzpicture}
\path node{$C_1$}
child { node{$C_2$}
  child { node{$S_3$}
    child { node{$S_4$} child { node{$F_5$} child { node{$3$} }}}
    child { node{$\times$} }
    child { node{$S_4$} child { node{$F_5$} child { node{$4$} }}}
  }
}
child { node{$+$} }
child{ node{$S_4$} child{ node{$F_5$} child{ node{$5$} }}}
;
\end{tikzpicture}
\]

This is the abstract syntax tree of the expression $3\times4+5$.
\[
\begin{tikzpicture}
\path node{$A_1$}
child { node{$A_3$}
  child { node{$A_5$} child { node{$3$} } }
  child { node{$\times$} }
  child { node{$A_5$} child { node{$4$} } }
}
child { node{$+$} }
child { node{$A_5$} child { node{$5$} } }
;
\end{tikzpicture}
\]

\subsection{Chomsky normal form} The input grammar is the
abstract grammar $A$ of arithmetic expressions. The output
grammar $N$ is the Chomsky normal form of $A$.
\begin{align*}
N &\R N~P & (N_1) \\
N &\R N~Q & (N_3) \\
N &\R \mbox{integer} & (N_5) \\
P &\R +~N & (P_1) \\
Q &\R \times~N & (Q_3)
\end{align*}

Intuitively, nodes labeled $A_1,A_3,A_5$ in abstract syntax trees
gets translated respectively to nodes labeled $N_1,N_3,N_5$ in
syntax trees in Chomsky normal form. The production $P_1$ comes
from $A_1$, and the production $Q_3$ comes from $A_3$.

This is the syntax tree of $3\times4+5$ in Chomsky normal form.
\[
\begin{tikzpicture}
\path node{$N_1$}
child { node{$N_3$}
  child { node{$N_5$} child { node{$4$} } }
  %child[draw opacity=0] {}
  child { node{$Q_3$}
    child { node{$\times$} }
    child { node{$N_5$} child { node{$5$} } }
  }
}
child[draw opacity=0] {}
child { node{$P_1$}
  child { node{$+$} }
  child { node{$N_5$} child { node{$2$} } }
};
\end{tikzpicture}
\]

\section{Information flows by example}

Each transformation between two grammars gives rise to a syntax
tree transformation. We will describe syntax tree transformations
by the information flow in the grammar transformation.

\subsection{Concrete and abstract grammars for arithmetic expressions}

To describe information flows, we need a unique identifier for
all terminals and nonterminals on the right-hand-side of a
production rule. Let us index nonterminals by superscripts.

This is the result of indexing the concrete grammar $C$.
\begin{align*}
C &\R C^1~+^2~S^3 & (C_1) \\
C &\R S^4     & (C_2) \\
S &\R S^5~\times^6~F^7 & (S_3) \\
S &\R F^8     & (S_4) \\
F &\R \mbox{integer}^9 & (F_5) \\
F &\R (~C^{10}~) & (F_6)
\end{align*}

This is the result of indexing the abstract grammar $A$. We add
a special trivial equation $A_0$, which corresponds to the
productions $C_2,S_4,F_6$ that are removed in the abstract
grammar. $A_0$ is not a real production; there are no $A_0$ nodes
in abstract syntax trees.
\begin{align*}
A &= A^0       & (A_0) \\
A &\R A^2~+^3~A^4 & (A_1) \\
A &\R A^5~\times^7~A^8 & (A_3) \\
A &\R \mbox{integer}^{10} & (A_5)
\end{align*}

Once nonterminals have unique identifiers, we can talk about
information flow. Let us describe the transformation from
concrete syntax trees to abstract syntax trees.
\begin{itemize}
\item $C_1$ nodes transform into $A_1$ nodes with information
flowing from $C^1$ to $A^2$, from $+^2$ to $+^3$, and from $S^3$
to $A^4$.
\item $C_2$ nodes transform into unknown abstract nodes with
information flowing from $S^4$ to $A^0$.
\item $S_3$ nodes transform into $A_3$ nodes with information
flowing from $S^5$ to $A^5$, from $\times^6$ to $\times^7$, and
from $F^7$ to $A^8$.
\item $S_4$ nodes transform into unknown abstract nodes with
information flowing from $F^8$ to $A^0$.
\item $F_5$ nodes transform into $A_5$ nodes with information
flowing from $\mbox{integer}^9$ to $\mbox{integer}^{10}$.
\item $F_6$ nodes transform into unknown abstract nodes with
information flowing from $C^{10}$ to $A^0$.
\end{itemize}

\subsection{Chomsky normal form}

This is the result of indexing the Chomsky normal form $N$ of the
abstract grammar $A$.
\begin{align*}
N &\R N^1~P^2 & (N_1) \\
N &\R N^3~Q^4 & (N_3) \\
N &\R \mbox{integer}^5 & (N_5) \\
P &\R +^6~N^7 & (P_1) \\
Q &\R \times^8~N^9 & (Q_3)
\end{align*}

Let us describe the transformation from syntax trees of $A$ to
syntax trees of $N$.
\begin{itemize}
\item $A_1$ nodes transform into $N_1$ nodes with information
flowing from $A^2$ to $N^1$, from $+^3$ through $P^2$ to $+^6$,
and from $A^4$ through $P^2$ to $N^7$.
\item $A_3$ nodes transform into $N_3$ nodes with information
flowing from $A^5$ to $N^3$, from $\times^7$ through $Q^4$ to
$\times^8$, and from $A^8$ through $Q^4$ to $N^9$.
\item $A_5$ nodes transform into $N_5$ nodes with information
flowing from $\mbox{integer}^{10}$ to $\mbox{integer}^5$.
\end{itemize}

\section{Information flows, formally}

An information flow between two context-free grammars can be
considered a collection of rewrite rules. We will define it
precisely here.

An \textbf{indexed grammar} is a context-free grammar with the
following changes:
\begin{enumerate}
\item Every occurrence of every symbol on right-hand-side of
production rules receives a unique, identifying superscript.
\item For each nonterminal $A$ in the grammar, add the equation
\[
A=A^0\qquad(A_0).
\]
\end{enumerate}

From now on, we assume the existence of two indexed grammars, an
\textbf{input} grammar and an \textbf{output} grammar.

An \textbf{information path} is a sequence of symbols
\[
(S^1,S^2,\ldots,S^m,T^n,\ldots,T^2,T^1),
\]
such that
\begin{enumerate}
\item $S^1,\ldots,S^m$ are terminal or nonterminal symbols of the
input grammar,
\item $T^n,\ldots,T^1$ are terminal or nonterminal symbols of the
output grammar,
\end{enumerate}
For example, in the transformation from the abstract grammar $A$
to the grammar $N$ in Chomsky normal form, the information path
from $+^3$ to $+^6$ is the sequence $(+^3,P^2,+^6)$.

An \textbf{information flow} is a collection of flow fragments. A
\textbf{flow fragment} is basically a rewrite rule between
different languages. Formally, a flow fragment is a tuple
$(R,S,P)$, where
\begin{enumerate}
\item $R$ is a production rule or equation in the input grammar,
\item $S$ is a production rule or equation in the output grammar,
\item $P$ is a set of information paths.
\end{enumerate}

This is the information flow from the concrete grammar $C$ to the
abstract grammar $A$:
\begin{align*}
(C_1,A_1,&\{(C^1,A^1),(+^2,+^2),(S^3,A^4)\})\\
(C_2,A_0,&\{(S^4,A^0)\})\\
(S_3,A_3,&\{(S^5,A^5),(\times^6,\times^7),(F^7,A^8)\})\\
(S_4,A_0,&\{(F^8,A^0)\})\\
(F_5,A_5,&\{(\mbox{integer}^9,\mbox{integer}^{10})\})\\
(F_6,A_0,&\{(C^{10},A^0)\})
\end{align*}

This is the information flow from the abstract grammar $A$ to the
grammar $N$ in Chomsky normal form:
\begin{align*}
(A_1,N_1,&\{(A^2,N^1),(+^3,P^2,+^6),(A^4,P^2,N^7)\})\\
(A_3,N_3,&\{(A^5,N^3),(\times^7,Q^4,\times^8),(A^8,Q^4,N^9)\})\\
(A_5,N_5,&\{(\mbox{integer}^{10},\mbox{integer}^5)\})
\end{align*}


\section{Well-formed and well-behaved information flows}

Well-formed information paths, well-formed flow fragments.

Unicity of insertions and deletions. Linearity of sources and
destinations.

Additional consistency requirements?


\section{Information flows as dialgebras}

From a well-formed and well-behaved information flow, we generate
a syntax tree transformation in 3 steps.
\begin{enumerate}
\item View the input grammar as the fixed point $\mu F$ of an
$n$-nary higher-order functor $F$. View the output grammar as the
fixed point $\mu G$ of an $n$-nary higher-order functor $G$.
\item Compile the information flow into an $F,G$-dialgebra of
type $F~\alpha\R G~\alpha$, where $\alpha$ can be either $\mu F$
or $\mu G$. Instantiating $\alpha$ to $\mu G$ produces the
$F$-algebra
\[
f : F~(\mu G) \R \mu G.
\]
Instantiating $\alpha$ to $\mu F$ produces the $G$-coalgebra
\[
g : \mu F \R G~(\mu F).
\]
\item The desired syntax tree transformation is given by the
catamorphism with respect to the $F$-algebra $f$. It is at the
same time the anamorphism with respect to the $G$-coalgebra $g$.
\end{enumerate}

\end{document}
